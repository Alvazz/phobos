syntax = "proto2";
import "nanopb.proto";

message ClustrilMessage {
    required uint32 timestamp =         1;
    optional string firmware_version =  2 [(nanopb).max_size = 7];

    optional Sensors sensors =          3;
    optional Actuators actuators =      4;

    optional BicycleState state =       5;
    optional BicycleInput input =       6;
    optional BicyclePose pose =         7;

    optional BicycleModel model =       8;
    optional Kalman kalman =            9;
}

// states are yaw, roll, steer, roll rate, steer rate (5)
message BicycleState {
    repeated float x = 1 [(nanopb).max_count = 5];
}

// inputs are roll torque, steer torque (2)
message BicycleInput {
    repeated float u = 1 [(nanopb).max_count = 2];
}

// message type for stm32 -> Unity communication
message BicyclePose {
    required uint32 timestamp = 1;
    required float x =          2;
    required float y =          3;
    required float yaw =        4;
    required float roll =       5;
    required float pitch =      6;
    required float steer =      7;
}

// STM32F4 ADC, DAC are 12-bit
message Sensors {
    required uint32 kistler_measured_torque =   1 [(nanopb).int_size = IS_16];
    required uint32 kollmorgen_actual_torque =  2 [(nanopb).int_size = IS_16];
    required uint32 steer_encoder_count =       3;

}

message Actuators {
    required uint32 kollmorgen_command_torque = 1 [(nanopb).int_size = IS_16];
}


// symmetric 5x5 matrix
message SymmetricStateMatrix {
    repeated float m = 1 [(nanopb).max_count = 15];
}

// symmetric 2x2 matrix
message SymmetricOutputMatrix {
    repeated float m = 1 [(nanopb).max_count = 3];
}

// 5x2 matrix
message KalmanGainMatrix {
    repeated float m = 1 [(nanopb).max_count = 10];
}

message Kalman {
    optional BicycleState state_estimate =                          1;
    optional SymmetricStateMatrix error_covariance =                2;
    optional SymmetricStateMatrix process_noise_covariance =        3;
    optional SymmetricOutputMatrix measurement_noise_covariance =   4;
    optional KalmanGainMatrix kalman_gain =                         5;
}

// 2x2 matrix
message SecondOrderMatrix {
    repeated float m = 1 [(nanopb).max_count = 4];
}

// 5x5 matrix
message StateMatrix {
    repeated float m = 1 [(nanopb).max_count = 25];
}

// 5x2 matrix
message InputMatrix {
    repeated float m = 1 [(nanopb).max_count = 10];
}

// 2x5 matrix
message OutputMatrix {
    repeated float m = 1 [(nanopb).max_count = 10];
}

// 2x2 matrix
message FeedthroughMatrix {
    repeated float m = 1 [(nanopb).max_count = 4];
}

message BicycleModel {
    optional float v =              1;
    optional float dt =             2;
    optional SecondOrderMatrix M =  3;
    optional SecondOrderMatrix C1 = 4;
    optional SecondOrderMatrix K0 = 5;
    optional SecondOrderMatrix K2 = 6;
    optional StateMatrix A =        7;
    optional InputMatrix B =        8;
    optional OutputMatrix C =       9;
    optional FeedthroughMatrix D =  10;
}
